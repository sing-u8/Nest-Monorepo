#클린아키텍처  #계층간_데이터전송
## 개요

 **포트와 어댑터(Ports and Adapters)** 개념이 바로 그 중심에 있으며, 이는 더 큰 원칙인 **의존성 역전 원칙(Dependency Inversion Principle)**을 구현하는 패턴입니다.

계층 간의 정보 교환을 이해하기 위한 핵심 개념은 크게 두 가지입니다.

1. **의존성 역전 원칙 (DIP)**: 통신의 '방향'과 '규칙'을 정합니다. (포트와 어댑터 패턴 사용)
    
2. **데이터 전송 객체 (DTO)**: 통신에 사용되는 데이터의 '형태'를 정의합니다.
    

이 개념들을 자세히 설명해 드릴게요.

---

### ## 1. 의존성 역전 원칙 (DIP)과 포트 & 어댑터

이것이 계층 간 통신의 가장 중요한 메커니즘입니다.

#### ### 필요한 이유

클린 아키텍처의 핵심 규칙은 **"의존성은 항상 안쪽으로 향해야 한다"**는 것입니다. 하지만 생각해보면 이상합니다. 안쪽 계층인 유스 케이스가 바깥쪽 계층인 데이터베이스에 데이터를 저장하려면, 유스 케이스가 데이터베이스를 "호출"해야 할 것 같잖아요? 만약 그렇게 직접 호출하면 의존성 규칙이 깨지고 맙니다.

**의존성 역전 원칙**은 이 문제를 해결합니다. 소스 코드의 의존성 방향(import 구문 등)은 규칙대로 안쪽을 향하게 유지하면서도, 실제 실행 흐름(제어 흐름)은 바깥쪽으로 향할 수 있게 해주는 마법 같은 원칙입니다.

#### ### 역할

**포트와 어댑터** 패턴은 의존성 역전 원칙을 구현하는 구체적인 방법입니다.

- **포트 (Port)**: 안쪽 계층(예: 유스 케이스)에 **인터페이스(interface)** 형태로 정의됩니다. "나는 이런 기능이 필요해"라고 선언하는 '요구사항 명세서'와 같습니다. 포트는 '무엇'을 할지만 정의하고 '어떻게' 할지는 정의하지 않습니다.
    
- **어댑터 (Adapter)**: 바깥쪽 계층(예: 인터페이스 어댑터, 프레임워크)에서 이 **포트 인터페이스를 실제로 구현한 클래스**입니다. '요구사항 명세서'를 보고 실제 기능을 만드는 '구현체'이죠.
    

이렇게 하면, 유스 케이스는 자신이 정의한 포트(인터페이스)에만 의존합니다. 실제 구현체인 어댑터는 바깥에 있으므로, **유스 케이스는 바깥 계층에 대해 아무것도 알 필요가 없게 됩니다.** 반면 어댑터 클래스는 포트 인터페이스를 구현(implements)해야 하므로, 어댑터의 소스 코드는 안쪽 계층의 포트를 의존(import)하게 됩니다. 완벽하게 의존성 규칙을 지키게 되는 것이죠!

#### ### 구성 요소

- **포트 (Port)**: **인터페이스** (Java의 `interface`, TypeScript의 `interface` 또는 `abstract class`)
    
- **어댑터 (Adapter)**: 포트 인터페이스를 **구현하는 구체적인 클래스**
    

#### ### 코드 구현 예시

이전 예제에서 이미 이 패턴을 사용했습니다. `BookRepository`가 포트, `InMemoryBookRepository`가 어댑터입니다.

**Java**

Java

```
// --- 안쪽 계층 (Use Cases)에 정의된 '포트' ---
// "어떻게든 책을 찾고 저장하는 기능이 필요하다"는 요구사항 명세서
public interface BookRepository { // Port
    Optional<Book> findById(String bookId);
    void save(Book book);
}

// --- 바깥쪽 계층 (Interface Adapters)에 정의된 '어댑터' ---
// "BookRepository의 요구사항을 메모리(Map)를 사용해서 구현하겠다"는 구체적인 구현체
public class InMemoryBookRepository implements BookRepository { // Adapter
    private final Map<String, Book> database = new HashMap<>();

    @Override
    public Optional<Book> findById(String bookId) { /* ...구현... */ }

    @Override
    public void save(Book book) { /* ...구현... */ }
}
```

**TypeScript**

TypeScript

```
// --- 안쪽 계층 (Use Cases)에 정의된 '포트' ---
export interface BookRepository { // Port
  findById(bookId: string): Promise<Book | null>;
  save(book: Book): Promise<void>;
}

// --- 바깥쪽 계층 (Interface Adapters)에 정의된 '어댑터' ---
export class InMemoryBookRepository implements BookRepository { // Adapter
  private readonly database: Map<string, Book> = new Map();

  async findById(bookId: string): Promise<Book | null> { /* ...구현... */ }
  async save(book: Book): Promise<void> { /* ...구현... */ }
}
```

---

### ## 2. 데이터 전송 객체 (Data Transfer Objects - DTOs)

DIP가 통신의 '방법'을 정의했다면, DTO는 '무엇을' 주고받을지 정의합니다.

#### ### 필요한 이유

계층 경계를 넘나드는 데이터는 단순하고 고립되어야 합니다. 만약 유스 케이스가 핵심 로직을 담고 있는 `Book` 엔티티 객체를 그대로 컨트롤러나 뷰(View)에 전달하면 어떻게 될까요? 뷰를 수정하는 사람이 엔티티의 내부 구조나 메서드까지 알아야 하고, 실수로 엔티티의 상태를 변경할 수도 있습니다. 이는 계층 간의 결합도를 높여 아키텍처를 무너뜨리는 원인이 됩니다.

DTO는 이러한 문제를 막기 위해 사용됩니다. **계층 간에 데이터를 전달하는 목적으로만 사용되는, 아무런 비즈니스 로직이 없는 순수한 데이터 덩어리**입니다.

#### ### 역할

- **데이터 격리**: 내부 계층의 복잡한 객체(엔티티 등)가 외부로 유출되는 것을 막습니다.
    
- **명확한 통신**: 각 계층이 통신에 필요한 데이터가 무엇인지 명확하게 정의할 수 있습니다. 예를 들어, '책 대출' 유스 케이스는 `bookId`와 `memberId`만 필요하지, 책의 모든 정보가 필요하지는 않습니다.
    
- **불변성**: DTO는 보통 불변(immutable) 객체로 만들어, 데이터가 전달 과정에서 예기치 않게 변경되는 것을 방지합니다.
    

#### ### 구성 요소

- **요청 모델 (Request Model)**: 외부에서 안쪽으로 데이터가 들어갈 때 사용되는 DTO (예: Controller -> Use Case)
    
- **응답 모델 (Response Model)**: 안쪽에서 외부로 데이터가 나갈 때 사용되는 DTO (예: Use Case -> Presenter)
    

#### ### 코드 구현 예시

이 또한 이전 예제에서 `Request`와 `Response`라는 이름으로 이미 사용했습니다.

**Java**

Java

```
// Controller -> Use Case 로 전달되는 순수한 데이터 객체 (DTO)
public record LendBookRequest(String bookId, String memberId) {}

// Use Case -> Presenter 로 전달되는 순수한 데이터 객체 (DTO)
public record LendBookResponse(String bookId, String title, boolean isLent) {}

// record는 데이터를 담는 목적의 불변 객체를 쉽게 만들어주는 Java 기능입니다.
```

**TypeScript**

TypeScript

```
// Controller -> Use Case 로 전달되는 순수한 데이터 객체 (DTO)
export interface LendBookRequest {
  readonly bookId: string;
  readonly memberId: string;
}

// Use Case -> Presenter 로 전달되는 순수한 데이터 객체 (DTO)
export interface LendBookResponse {
  readonly bookId: string;
  readonly title: string;
  readonly isLent: boolean;
}

// readonly 키워드를 사용해 불변성을 강제할 수 있습니다.
```

결론적으로, 클린 아키텍처의 계층들은 **의존성 역전 원칙(DIP)에 따라 포트와 어댑터 패턴으로 '연결'되고, 경계를 넘나드는 정보는 순수한 'DTO'에 담겨 '전달'**됩니다. 이 두 가지 원칙이 바로 견고하고 유연한 아키텍처를 만드는 비결입니다.