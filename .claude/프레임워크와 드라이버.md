#클린아키텍처  #계층 

### ## 필요한 이유

소프트웨어는 혼자 존재할 수 없습니다. 사용자, 데이터베이스, 다른 시스템 등 외부 세계와 소통해야만 의미가 있죠. 프레임워크와 드라이버는 바로 이 **소통을 가능하게 하는 구체적인 도구들**입니다. 웹 서버를 띄우기 위한 웹 프레임워크, 데이터베이스와 대화하기 위한 DB 드라이버, 화면을 그리기 위한 UI 프레임워크 등이 모두 여기에 속합니다.

클린 아키텍처의 관점에서 이 도구들은 **'세부 사항(details)'**입니다. 세부 사항은 중요하지만, 변덕스럽고 자주 바뀔 수 있습니다. 이 계층은 이러한 변덕스러운 세부 사항들을 한곳에 모아두는 역할을 합니다. 애플리케이션의 핵심 로직(안쪽 원들)을 이 세부 사항들로부터 보호하고, 필요할 때 **마치 부품(플러그인)처럼 쉽게 교체**할 수 있도록 만들기 위해 반드시 필요합니다.

**핵심: 애플리케이션을 실제 세상과 연결하는 구체적인 기술들을 담는 곳이며, 이 기술들을 '세부 사항'으로 취급하여 핵심 로직과 격리하기 위함입니다.** 🚗

---

### ## 어떤 역할을 하는가?

이 계층은 시스템의 가장 낮은 수준의 작업을 담당하며, **접착제(glue)**와 같은 역할을 합니다.

- **애플리케이션 부팅 및 초기화**: 시스템이 시작되는 진입점(`main` 함수 등)이 여기에 위치합니다. 웹 서버를 시작하고, 데이터베이스 연결을 설정하고, 모든 객체를 생성하고 연결하는 초기화 코드를 담당합니다.
    
- **의존성 주입(Dependency Injection)**: 이전 단계들에서 만든 모든 조각들(리포지토리 구현체, 유스 케이스, 컨트롤러 등)을 생성하고 서로에게 주입하여 전체 애플리케이션을 조립합니다. 이곳을 보통 **구성 루트(Composition Root)**라고 부릅니다.
    
- **외부 세계와의 최종 연결**: 컨트롤러를 웹 프레임워크의 라우팅 규칙에 연결하거나, UI 이벤트를 컨트롤러에 전달하는 등 외부 세계와 인터페이스 어댑터 계층을 최종적으로 연결합니다.
    

**핵심: 모든 것을 하나로 묶어 실제 작동하는 애플리케이션으로 만드는 '최종 조립'과 '실행'을 담당합니다.**

---

### ## 어떤 구성요소가 있는가?

이 계층은 구체적인 기술 그 자체로 이루어집니다.

- **웹 프레임워크**: Spring Boot, Express.js, Django, Ruby on Rails 등
    
- **데이터베이스 드라이버**: JDBC, node-postgres, SQLAlchemy 등
    
- **UI 프레임워크**: React, Vue, Angular, Swing 등
    
- **메인(Main) 컴포넌트**: 애플리케이션의 시작점 (`public static void main`, `if __name__ == "__main__"`)
    
- **의존성 주입(DI) 프레임워크 또는 컨테이너**: Spring IoC, Guice, NestJS DI 등 (사용하지 않고 직접 코드로 구성할 수도 있습니다.)
    
- **서드파티 라이브러리**: 외부 API 클라이언트 등
    

---

### ## 코드 구현 예시 (Java & TypeScript)

지금까지 만들었던 모든 조각들(Repository, Use Case, Controller)을 조립하여 애플리케이션을 실행하는 **Main** 부분을 구현해 보겠습니다.

#### ### 자바 (Java) 구현 예시

`Main` 클래스에서 모든 객체를 생성하고 연결(wiring)합니다.

Java

```
// Main.java (애플리케이션의 시작점)
public class Main {
    public static void main(String[] args) {
        System.out.println("애플리케이션을 시작합니다...");

        // ================== 구성 루트 (Composition Root) ==================
        // 1. Frameworks & Drivers 계층의 구체적인 구현체를 생성합니다.
        BookRepository bookRepository = new InMemoryBookRepository();

        // 2. Use Cases 계층의 구현체를 생성하고, 의존성을 주입합니다.
        LendBookUseCase lendBookUseCase = new LendBookInteractor(bookRepository);

        // 3. Interface Adapters 계층의 구현체를 생성하고, 의존성을 주입합니다.
        BookApiController bookApiController = new BookApiController(lendBookUseCase);
        // =================================================================

        // 초기 데이터 설정
        Book initialBook = new Book("B001", "클린 아키텍처");
        bookRepository.save(initialBook);

        // --- 가상 시나리오: 웹 요청이 들어왔다고 가정 ---
        System.out.println("\n'B001' 책을 대출하는 API 요청이 들어왔습니다.");
        
        // 컨트롤러의 메서드를 호출하여 유스케이스를 실행합니다.
        ApiResponse<LendBookResponse> response = bookApiController.lendBook("B001", "M001");

        // 프레젠터가 반환한 최종 결과를 출력합니다.
        System.out.println("API 응답: " + response);

        // --- 가상 시나리오: 동일한 책에 대한 두 번째 요청 ---
        System.out.println("\n'B001' 책을 다시 대출하는 API 요청이 들어왔습니다.");
        ApiResponse<LendBookResponse> secondResponse = bookApiController.lendBook("B001", "M002");
        System.out.println("API 응답: " + secondResponse);
    }
}
```

- **설명**: `main` 메서드가 어떻게 각 계층의 구체적인 클래스들을 생성하고 서로 연결하는지 주목해주세요. 이것이 바로 의존성 주입이며, 프레임워크와 드라이버 계층의 핵심 역할입니다.
    

#### ### 타입스크립트 (TypeScript) 구현 예시

Express.js 웹 프레임워크를 사용하여 서버를 설정하고 실행하는 예시입니다.

TypeScript

```
// server.ts (애플리케이션의 시작점)
import express, { Request, Response } from 'express';
import { BookController } from './adapters/book.controller';
import { LendBookUseCase } from './use-cases/lend-book.use-case';
import { InMemoryBookRepository } from './drivers/in-memory-book.repository';
import { Book } from './entities/Book';

// ================== 구성 루트 (Composition Root) ==================
// 1. Frameworks & Drivers: Repository 구현체 생성
const bookRepository = new InMemoryBookRepository();

// 2. Use Cases: 유스케이스 생성 및 의존성 주입
const lendBookUseCase = new LendBookUseCase(bookRepository);

// 3. Interface Adapters: 컨트롤러 생성 및 의존성 주입
const bookController = new BookController(lendBookUseCase);
// =================================================================

// 초기 데이터 설정
const initialBook = new Book("B001", "클린 아키텍처");
bookRepository.save(initialBook);


// ================== Frameworks & Drivers: Express 설정 ==================
const app = express();
app.use(express.json());

// 외부 요청(API 엔드포인트)과 컨트롤러를 연결
app.post('/books/:bookId/lend', (req: Request, res: Response) => {
  // express의 req, res 객체를 컨트롤러에 넘겨줍니다.
  bookController.lendBook(req, res);
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`서버가 http://localhost:${PORT} 에서 실행 중입니다.`);
});
```

- **설명**: 이 파일은 애플리케이션의 모든 부분을 '조립'하고 Express라는 '드라이버'를 사용하여 웹 서버를 '실행'합니다. API 경로(`/books/:bookId/lend`)를 컨트롤러의 메서드에 연결하는 부분이 바로 이 계층의 역할입니다.
    

이제 4개의 계층을 모두 둘러보았습니다. 이 구조를 통해 비즈니스 규칙은 외부 변화에 흔들리지 않는 견고한 요새처럼 보호받고, 외부 기술들은 필요에 따라 쉽게 교체할 수 있는 유연성을 얻게 됩니다. 이것이 로버트 C. 마틴이 말하는 **클린 아키텍처**의 정수입니다.
