#클린아키텍처 #계층


엔티티는 클린 아키텍처 다이어그램의 가장 안쪽 원에 위치하며, 시스템의 전체를 관통하는 가장 핵심적인 부분을 담당합니다. 하나씩 차근차근 알아보겠습니다.

---

### ## 엔티티가 필요한 이유

엔티티 계층은 **소프트웨어의 수명과 안정성을 결정짓는 핵심적인 역할**을 합니다.

기술은 빠르게 변합니다. 10년 전 유행하던 웹 프레임워크나 데이터베이스는 지금은 잘 쓰이지 않을 수 있죠. 만약 우리의 핵심 비즈니스 로직(예: 은행의 이자 계산 로직)이 특정 프레임워크나 데이터베이스 코드와 뒤섞여 있다면 어떻게 될까요? 기술을 교체할 때마다 비즈니스 로직까지 전부 새로 짜야 하는 끔찍한 상황이 발생할 수 있습니다.

엔티티는 바로 이 문제를 해결합니다. **가장 변하지 않아야 할 핵심 규칙들을 외부의 변화로부터 보호하는 방화벽** 역할을 하는 것입니다. 비즈니스의 본질(예: '책을 대출한다')은 기술의 변화(예: 웹사이트에서 모바일 앱으로 변경)와 상관없이 거의 변하지 않습니다. 엔티티를 독립적으로 유지함으로써, 우리는 바깥 계층의 프레임워크나 UI, DB를 자유롭게 교체하면서도 시스템의 핵심 가치를 오랫동안 안정적으로 지켜낼 수 있습니다.

**핵심: 비즈니스의 본질을 기술의 변화로부터 분리하여 소프트웨어를 유연하고 지속 가능하게 만들기 위함입니다.** 🏛️

---

### ## 엔티티의 역할

엔티티는 **전사적인 핵심 업무 규칙(Enterprise-wide Business Rules)**을 캡슐화합니다.

여기서 '전사적'이라는 말은 특정 애플리케이션에만 국한되지 않는, 그 비즈니스 도메인 전체에서 통용되는 보편적인 규칙이라는 의미입니다.

- **역할 1: 비즈니스 데이터의 구조 정의**: 엔티티는 '고객', '상품', '계좌'와 같이 비즈니스에서 다루는 핵심 데이터가 무엇인지, 어떤 속성들을 갖는지 정의합니다.
    
- **역할 2: 핵심 행동 및 규칙 포함**: 엔티티는 단순히 데이터 껍데기가 아닙니다. 그 데이터와 관련된 가장 중요한 행동이나 정책, 검증 규칙을 **메서드** 형태로 포함하고 있어야 합니다. 예를 들어, '계좌' 엔티티는 `출금하다()`라는 메서드를 가질 수 있고, 이 메서드 안에는 "잔액보다 많은 금액은 출금할 수 없다"는 핵심 규칙이 구현되어 있습니다.
    

**핵심: 엔티티는 외부 세계(UI, DB 등)에 대해 아무것도 모르는 순수한 비즈니스 모델 그 자체입니다.**

---

### ## 엔티티의 구성 요소

엔티티는 매우 단순한 구조를 가집니다. 특정 프레임워크나 라이브러리에 의존하지 않는 순수한 객체(Plain Old Object)입니다.

1. **속성 (Attributes)**: 비즈니스 데이터를 나타내는 필드입니다. (예: `Book` 엔티티의 `title`, `author`)
    
2. **메서드 (Methods)**: 핵심 업무 규칙을 수행하는 함수입니다. 이 메서드들이 바로 엔티티의 존재 이유입니다. (예: `Book` 엔티티의 `대출하다()`, `반납하다()`)
    

**중요한 점**: 엔티티는 DB 테이블의 구조나 화면 UI의 모양에 맞춰 설계되어서는 **안 됩니다.** 오직 순수한 비즈니스 관점에서만 설계되어야 합니다.

---

### ## 코드 구현 예시 (Java & TypeScript)

간단한 '도서관 대출' 시나리오를 생각해보겠습니다. 여기서 핵심 엔티티는 `Book`이 될 것입니다. `Book`의 핵심 비즈니스 규칙 중 하나는 **"이미 대출 중인 책은 다시 대출할 수 없다"** 입니다.

#### ### 자바 (Java) 구현 예시

Java에서는 보통 순수한 클래스(POJO, Plain Old Java Object)로 엔티티를 만듭니다.

Java

```
// Book.java
// 어떠한 프레임워크 어노테이션(@Entity, @Data 등)도 사용하지 않은 순수한 클래스입니다.

public class Book {
    private final String title;
    private final String author;
    private boolean isLent; // 대출 상태

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
        this.isLent = false; // 기본 상태는 '대출 가능'
    }

    // 핵심 비즈니스 규칙을 담고 있는 메서드
    public void lend() throws IllegalStateException {
        if (this.isLent) {
            // "이미 대출 중인 책은 대출할 수 없다"는 규칙을 강제합니다.
            throw new IllegalStateException("이 책은 이미 대출 중입니다.");
        }
        this.isLent = true;
        System.out.println("'" + this.title + "' 책이 대출되었습니다.");
    }

    public void returnBook() {
        this.isLent = false;
        System.out.println("'" + this.title + "' 책이 반납되었습니다.");
    }

    // Getter 메서드들
    public String getTitle() {
        return title;
    }

    public String getAuthor() {
        return author;
    }

    public boolean isLent() {
        return isLent;
    }
}
```

- **설명**: `lend()` 메서드 안에 `isLent` 상태를 확인하는 로직이 포함된 것이 보이시나요? 이것이 바로 **엔티티가 스스로 자신의 규칙을 지키는 모습**입니다. 이 `Book` 클래스는 데이터베이스나 웹 기술과 완전히 독립적입니다.
    

#### ### 타입스크립트 (TypeScript) 구현 예시

TypeScript에서도 프레임워크에 의존하지 않는 순수한 `class`로 구현합니다.

TypeScript

```
// Book.ts
// 특정 라이브러리나 프레임워크 import가 없는 순수한 클래스입니다.

export class Book {
  public readonly title: string;
  public readonly author: string;
  private isLent: boolean;

  constructor(title: string, author: string) {
    this.title = title;
    this.author = author;
    this.isLent = false; // 기본 상태는 '대출 가능'
  }

  /**
   * 핵심 비즈니스 규칙을 담고 있는 메서드
   */
  public lend(): void {
    if (this.isLent) {
      // "이미 대출 중인 책은 대출할 수 없다"는 규칙을 강제합니다.
      throw new Error("이 책은 이미 대출 중입니다.");
    }
    this.isLent = true;
    console.log(`'${this.title}' 책이 대출되었습니다.`);
  }

  public returnBook(): void {
    this.isLent = false;
    console.log(`'${this.title}' 책이 반납되었습니다.`);
  }

  public getIsLent(): boolean {
    return this.isLent;
  }
}
```

- **설명**: TypeScript 예시도 Java와 본질적으로 동일합니다. `Book` 클래스는 자신의 상태(`isLent`)와 그 상태를 변경하는 규칙(`lend` 메서드)을 스스로 관리합니다. 이 `Book` 클래스는 Node.js, 브라우저 등 어떤 환경에서도 독립적으로 실행될 수 있습니다.