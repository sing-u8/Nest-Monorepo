#클린아키텍처 #계층 

이 계층의 이름 그대로, 이곳은 **서로 다른 인터페이스(규격)를 가진 것들을 서로 연결(adapt)해주는 변환기(adapter)들의 집합**입니다.

---

### ## 필요한 이유

내부 계층(엔티티, 유스 케이스)은 오직 순수한 비즈니스 로직에만 집중합니다. 이들은 데이터가 웹 페이지에서 오는지, 데이터베이스에 어떻게 저장되는지 전혀 관심이 없습니다. 반대로, 외부의 프레임워크나 데이터베이스는 내부의 비즈니스 객체 형식을 알지 못합니다.

인터페이스 어댑터는 이 둘 사이의 **'번역가'** 역할을 합니다. 만약 이 계층이 없다면, 유스 케이스가 직접 HTTP 요청을 해석하거나 SQL 쿼리를 작성해야 할 겁니다. 그렇게 되면 핵심 로직이 외부 기술에 오염되고, 기술이 바뀔 때마다 핵심 로직 전체를 수정해야 하는 재앙이 발생합니다.

이 계층은 내부의 안정적인 정책과 외부의 불안정한 세부사항 사이에 **방화벽**을 세워, **의존성 규칙**("소스 코드 의존성은 오직 안쪽으로만 향해야 한다")이 깨지지 않도록 보장합니다.

**핵심: 내부의 순수한 비즈니스 로직을 외부 세계의 구체적인 기술과 형식으로부터 완전히 분리하여, 시스템의 유연성과 독립성을 확보하기 위함입니다.** 🔌

---

### ## 어떤 역할을 하는가?

인터페이스 어댑터 계층은 **데이터 형식 변환**과 **경계(Boundary) 간의 통신**을 담당합니다.

- **입력 처리**: 웹 컨트롤러(Controller)는 HTTP 요청 같은 외부 입력을 받아서, 유스 케이스가 이해할 수 있는 간단한 데이터 객체(Request Model)로 변환한 뒤, 유스 케이스의 입력 포트를 호출합니다.
    
- **출력 처리**: 프레젠터(Presenter)는 유스 케이스의 출력 포트를 구현합니다. 유스 케이스로부터 결과 데이터(Response Model)를 받아서, 웹이나 UI가 표현하기 좋은 데이터 형식(View Model)으로 가공합니다.
    
- **데이터 영속성 구현**: 게이트웨이(Gateway) 또는 리포지토리(Repository)는 유스 케이스 계층에 정의된 '데이터 저장소 인터페이스'의 실제 구현체를 제공합니다. 예를 들어, `BookRepository`라는 인터페이스를 `PostgresBookRepository`라는 클래스로 구현하여 실제 PostgreSQL 데이터베이스와 통신하는 코드를 작성합니다.
    

**핵심: 유스 케이스와 외부 세계 사이에서 양방향으로 데이터를 번역하고 전달하는 모든 종류의 어댑터 역할을 수행합니다.**

---

### ## 어떤 구성요소가 있는가?

이 계층은 다양한 종류의 어댑터를 포함합니다. 대표적인 구성요소는 다음과 같습니다.

- **컨트롤러 (Controllers)**: 웹 프레임워크, GUI, CLI 등으로부터 입력을 받아 유스 케이스를 실행시키는 역할.
    
- **프레젠터 (Presenters)**: 유스 케이스의 처리 결과를 받아 UI나 외부 시스템이 사용하기 좋은 형태로 데이터를 가공하는 역할.
    
- **게이트웨이 / 리포지토리 구현체 (Gateways / Repositories)**: 유스 케이스 계층의 데이터 접근 인터페이스(`BookRepository`)를 실제 DB 기술(`PostgreSQL`, `MongoDB`, `In-Memory`)을 사용하여 구현한 클래스. 여기서 **의존성 역전 원칙(DIP)**이 빛을 발합니다.
    

---

### ## 코드 구현 예시 (Java & TypeScript)

'책 대출' 유스 케이스를 위한 컨트롤러, 프레젠터, 리포지토리 구현체를 만들어 보겠습니다.

#### ### 자바 (Java) 구현 예시

1. 리포지토리 구현체 (Gateway)

이전 답변의 BookRepository 인터페이스를 실제로 구현합니다.

Java

```
// InMemoryBookRepository.java
// :BookRepository 인터페이스의 '인메모리' 버전 구현체. 실제 DB 대신 Map을 사용.
public class InMemoryBookRepository implements BookRepository {
    private final Map<String, Book> database = new HashMap<>();

    @Override
    public Optional<Book> findById(String bookId) {
        return Optional.ofNullable(database.get(bookId));
    }

    @Override
    public void save(Book book) {
        database.put(book.getId(), book);
    }
}
```

2. 컨트롤러와 프레젠터

간단한 웹 API 상황을 가정합니다.

Java

```
// BookApiController.java (Controller 역할)
public class BookApiController {
    private final LendBookUseCase lendBookUseCase;

    public BookApiController(LendBookUseCase lendBookUseCase) {
        this.lendBookUseCase = lendBookUseCase;
    }

    // 예: POST /books/B001/lend
    public ApiResponse<LendBookResponse> lendBook(String bookId, String memberId) {
        // 1. 프레젠터(출력 포트)를 준비합니다.
        BookApiPresenter presenter = new BookApiPresenter();

        // 2. 외부 요청(HTTP)을 유스케이스 입력 모델로 변환합니다.
        LendBookRequest request = new LendBookRequest(bookId, memberId);

        // 3. 유스케이스를 실행합니다.
        lendBookUseCase.execute(request, presenter);

        // 4. 프레젠터가 가공한 결과를 반환합니다.
        return presenter.getApiResponse();
    }
}

// BookApiPresenter.java (Presenter 역할)
// :LendBookOutputPort 인터페이스의 구현체.
public class BookApiPresenter implements LendBookOutputPort {
    private ApiResponse<LendBookResponse> apiResponse;

    @Override
    public void presentSuccess(LendBookResponse response) {
        this.apiResponse = ApiResponse.success(response);
    }

    @Override
    public void presentError(String message) {
        this.apiResponse = ApiResponse.error(message);
    }

    public ApiResponse<LendBookResponse> getApiResponse() {
        return apiResponse;
    }
}
```

#### ### 타입스크립트 (TypeScript) 구현 예시

1. 리포지토리 구현체 (Gateway)

이전 답변의 BookRepository 인터페이스를 실제로 구현합니다.

TypeScript

```
// in-memory-book.repository.ts
import { Book } from './entities/Book';
import { BookRepository } from './book.repository';

export class InMemoryBookRepository implements BookRepository {
  private readonly database: Map<string, Book> = new Map();

  async findById(bookId: string): Promise<Book | null> {
    return this.database.get(bookId) || null;
  }

  async save(book: Book): Promise<void> {
    this.database.set(book.id, book);
  }
}
```

2. 컨트롤러와 프레젠터

Express.js와 같은 웹 프레임워크 환경을 가정합니다.

TypeScript

```
// book.controller.ts (Controller 역할)
import { Request, Response } from 'express';
import { LendBookUseCase } from './lend-book.use-case';
import { LendBookRequest, LendBookOutputPort, LendBookResponse } from './lend-book.types';

// Presenter를 Controller 내부에 간단한 객체로 구현
class BookApiPresenter implements LendBookOutputPort {
  constructor(private res: Response) {}

  presentSuccess(response: LendBookResponse): void {
    this.res.status(200).json(response);
  }

  presentError(message: string): void {
    this.res.status(400).json({ error: message });
  }
}

export class BookController {
  constructor(private readonly lendBookUseCase: LendBookUseCase) {}

  public async lendBook(req: Request, res: Response): Promise<void> {
    // 1. 프레젠터(출력 포트)를 준비합니다.
    const presenter = new BookApiPresenter(res);
    
    // 2. 외부 요청(HTTP)을 유스케이스 입력 모델로 변환합니다.
    const request: LendBookRequest = {
      bookId: req.params.bookId,
      memberId: req.body.memberId,
    };
    
    // 3. 유스케이스를 실행합니다. 결과는 presenter가 처리합니다.
    await this.lendBookUseCase.execute(request, presenter);
  }
}
```

보시는 것처럼, 인터페이스 어댑터 계층은 애플리케이션의 핵심 로직을 특정 기술로부터 깔끔하게 분리하여, 시스템을 훨씬 더 유연하고 견고하게 만들어줍니다. 