#클린아키텍처 #계층

### ## 유스 케이스가 필요한 이유

엔티티가 **무엇**을 할 수 있는지(규칙)를 정의한다면, 유스 케이스는 그 규칙들을 **어떻게** 사용하여 사용자에게 가치 있는 기능을 제공할지를 결정합니다.

만약 유스 케이스 계층이 없다면, UI를 제어하는 컨트롤러나 웹 요청을 받는 핸들러가 직접 엔티티를 만지고 데이터베이스에 접근하게 될 겁니다. 이렇게 되면 애플리케이션의 정책이 UI나 프레임워크 코드와 뒤섞여 버립니다. 그 결과, UI가 바뀌면 업무 로직도 수정해야 하고, 테스트는 항상 실제 데이터베이스와 웹 서버를 필요로 하는 복잡하고 깨지기 쉬운 구조가 됩니다.

유스 케이스 계층은 **애플리케이션의 정책을 외부 세계로부터 격리하는 방화벽** 역할을 합니다. 이를 통해 다음과 같은 장점을 얻습니다.

- **테스트 용이성**: UI나 DB 없이도 애플리케이션의 핵심 기능을 완벽하게 테스트할 수 있습니다.
    
- **유연성**: 웹 컨트롤러, CLI(명령줄 인터페이스), 배치(Batch) 작업 등 어떤 전달 메커니즘에서도 동일한 유스 케이스를 재사용할 수 있습니다.
    
- **의존성 관리**: "안쪽으로만 의존한다"는 클린 아키텍처의 핵심 원칙을 강제하여, 안정적인 코드가 불안정한 코드에 의존하지 않도록 만듭니다.
    

**핵심: 애플리케이션의 고유한 시나리오와 정책을 캡슐화하여, 시스템을 유연하고 테스트하기 쉽게 만들기 위함입니다.** ⚙️

---

### ## 유스 케이스의 역할

유스 케이스는 **애플리케이션에 특화된 업무 규칙(Application-specific Business Rules)**을 실행하는 조정자(Orchestrator)입니다.

하나의 유스 케이스 클래스는 보통 사용자가 시스템으로 수행하려는 단일 기능(예: '사용자 등록', '게시글 작성', '책 대출')을 책임집니다.

- **역할 1: 데이터 흐름 조정**: 입력 데이터를 받아 어떤 엔티티를 사용하고 어떤 순서로 메서드를 호출할지 결정합니다.
    
- **역할 2: 엔티티 조작**: 데이터베이스 등에서 엔티티를 가져와서 필요한 작업을 수행하도록 지시합니다. (예: `book.lend()`)
    
- **역할 3: 결과 반환**: 작업 결과를 출력 포트(Presenter)를 통해 외부 계층에 전달합니다.
    

**핵심: 유스 케이스는 입력(Request)을 받아 엔티티와 상호작용한 뒤, 출력(Response)을 내보내는 하나의 완전한 트랜잭션을 책임집니다.**

---

### ## 유스 케이스의 구성 요소

유스 케이스는 보통 여러 구성 요소의 조합으로 이루어집니다.

1. **입력 포트 (Input Port)**: 유스 케이스가 외부에 제공하는 인터페이스(API)입니다. 보통 `execute()` 같은 단일 메서드를 가집니다.
    
2. **입력 모델 (Input Model / Request Model)**: 유스 케이스를 실행하는 데 필요한 데이터를 담는 단순한 데이터 구조체(DTO)입니다.
    
3. **유스 케이스 구현체 (Use Case Interactor)**: 입력 포트를 구현한 메인 클래스입니다. 핵심 로직이 여기에 들어갑니다.
    
4. **출력 포트 (Output Port)**: 유스 케이스의 결과를 외부 계층(주로 Presenter)에 전달하기 위한 인터페이스입니다.
    
5. **출력 모델 (Output Model / Response Model)**: 유스 케이스의 결과 데이터를 담는 단순한 데이터 구조체입니다.
    
6. **엔티티 게이트웨이 (Entity Gateway / Repository)**: 데이터베이스에서 엔티티를 가져오거나 저장하는 역할을 하는 인터페이스입니다. 유스 케이스는 이 **인터페이스에만 의존**하고, 실제 구현은 알지 못합니다. (의존성 역전 원칙)
    

---

### ## 코드 구현 예시 (Java & TypeScript)

앞서 만든 `Book` 엔티티를 사용하여 **'책을 대출하는' 유스 케이스**를 구현해 보겠습니다.

#### ### 자바 (Java) 구현 예시

Java에서는 인터페이스를 적극적으로 활용하여 각 구성 요소를 명확히 분리합니다.

**1. 유스 케이스 인터페이스 (입력/출력 포트)**

Java

```
// LendBookUseCase.java (Input Port)
public interface LendBookUseCase {
    void execute(LendBookRequest request, LendBookOutputPort presenter);
}

// LendBookOutputPort.java (Output Port)
public interface LendBookOutputPort {
    void presentSuccess(LendBookResponse response);
    void presentError(String message);
}

// BookRepository.java (Entity Gateway)
public interface BookRepository {
    Optional<Book> findById(String bookId);
    void save(Book book);
}
```

**2. 데이터 모델 (입력/출력)**

Java

```
// LendBookRequest.java
public record LendBookRequest(String bookId, String memberId) {}

// LendBookResponse.java
public record LendBookResponse(String bookId, String title, boolean isLent) {}
```

**3. 유스 케이스 구현체 (Interactor)**

Java

```
// LendBookInteractor.java
public class LendBookInteractor implements LendBookUseCase {
    private final BookRepository bookRepository;

    // 데이터베이스 구현이 아닌, Repository 인터페이스에 의존합니다.
    public LendBookInteractor(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

    @Override
    public void execute(LendBookRequest request, LendBookOutputPort presenter) {
        // 1. 책을 찾는다.
        Book book = bookRepository.findById(request.bookId())
                .orElseThrow(() -> new NoSuchElementException("해당 ID의 책이 없습니다."));

        try {
            // 2. 엔티티의 핵심 로직을 호출한다.
            book.lend();
            
            // 3. 변경된 상태를 저장한다.
            bookRepository.save(book);

            // 4. 성공 결과를 Presenter에 전달한다.
            LendBookResponse response = new LendBookResponse(book.getId(), book.getTitle(), book.isLent());
            presenter.presentSuccess(response);
        } catch (IllegalStateException e) {
            // 5. 실패 결과를 Presenter에 전달한다.
            presenter.presentError(e.getMessage());
        }
    }
}
```

#### ### 타입스크립트 (TypeScript) 구현 예시

TypeScript에서도 인터페이스 기반으로 의존성을 관리하는 것이 핵심입니다.

**1. 유스 케이스 인터페이스 (타입/인터페이스)**

TypeScript

```
// book.repository.ts (Entity Gateway)
import { Book } from './entities/Book';
export interface BookRepository {
  findById(bookId: string): Promise<Book | null>;
  save(book: Book): Promise<void>;
}

// lend-book.types.ts (Input/Output Ports & Models)
export interface LendBookRequest {
  bookId: string;
  memberId: string;
}

export interface LendBookResponse {
  bookId: string;
  title: string;
  isLent: boolean;
}

export interface LendBookOutputPort {
  presentSuccess(response: LendBookResponse): void;
  presentError(message: string): void;
}
```

**2. 유스 케이스 구현체 (Interactor)**

TypeScript

```
// lend-book.use-case.ts
import { BookRepository } from './book.repository';
import { LendBookRequest, LendBookOutputPort, LendBookResponse } from './lend-book.types';

export class LendBookUseCase {
  // 데이터베이스 구현이 아닌, Repository 인터페이스에 의존합니다.
  constructor(private readonly bookRepository: BookRepository) {}

  public async execute(request: LendBookRequest, presenter: LendBookOutputPort): Promise<void> {
    // 1. 책을 찾는다.
    const book = await this.bookRepository.findById(request.bookId);
    if (!book) {
      return presenter.presentError("해당 ID의 책이 없습니다.");
    }

    try {
      // 2. 엔티티의 핵심 로직을 호출한다.
      book.lend();

      // 3. 변경된 상태를 저장한다.
      await this.bookRepository.save(book);
      
      // 4. 성공 결과를 Presenter에 전달한다.
      const response: LendBookResponse = {
        bookId: book.id,
        title: book.title,
        isLent: book.getIsLent(),
      };
      presenter.presentSuccess(response);
    } catch (error: any) {
      // 5. 실패 결과를 Presenter에 전달한다.
      presenter.presentError(error.message);
    }
  }
}
```

이처럼 유스 케이스는 **오케스트레이션**에 집중하고, 실제 업무 규칙은 **엔티티**가, 데이터 영속성은 **리포지토리**가, 결과 표현은 **프레젠터**가 담당하도록 역할을 명확히 나눕니다. 이것이 바로 클린 아키텍처의 힘입니다.
